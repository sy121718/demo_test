# 业务层规范

## 1. 基本原则

### 1.1 分层职责
- **模型层（Model）**: 负责简单的数据操作和基础业务逻辑
- **业务层（Service）**: 负责复杂业务逻辑、跨模型操作和业务流程编排
- **控制器层（Controller）**: 负责请求处理、参数验证和响应返回

### 1.2 代码复用原则
- **公共方法优先**: 能写公共的方法就写公共的去调用，避免重复代码
- **适当下沉**: 简单的业务逻辑可以直接写到模型里面，如查唯一性、查询超管等基础操作
- **复杂上移**: 复杂的业务逻辑（如树状结构处理、多表关联、业务流程）必须写在业务层

## 2. 模型层规范

### 2.1 适合在模型中实现的方法
```php
// 查询唯一性验证
public function checkUnique($field, $value, $excludeId = null)
{
    $where = [$field => $value];
    if ($excludeId) {
        $where['id'] = ['<>', $excludeId];
    }
    return $this->where($where)->count() === 0;
}

// 查询超级管理员
public function isSuperAdmin($userId)
{
    return $this->where('id', $userId)->where('is_super', 1)->count() > 0;
}

// 基础状态操作
public function changeStatus($id, $status)
{
    return $this->where('id', $id)->update(['status' => $status]);
}
```

### 2.2 模型命名规范
- 系统相关模型：`app/model/system/` 目录下
- 权限相关模型：`app/model/auth/` 目录下
- 业务相关模型：按业务模块分目录存放

## 3. 业务层规范

### 3.1 组织原则
- **一对一原则**: 每个模型对应一个业务层服务类
- **独立性原则**: 每个业务层只处理自己对应模型的复杂业务逻辑
- **通信原则**: 不同业务层之间通过依赖注入进行通信，不能混写

### 3.2 业务层适用场景
```php
// 树状结构处理
public function getMenuTree($parentId = 0)
{
    // 复杂的树形结构构建逻辑
}

// 多表关联复杂查询
public function getUserWithRolesAndPermissions($userId)
{
    // 跨多个模型的复杂查询逻辑
}

// 复杂业务流程
public function processUserRegistration($userData)
{
    // 用户注册的完整业务流程
}
```

### 3.3 业务层命名规范
- 服务类命名：`{模型名}Service`，如 `UserService`、`MenuService`
- 文件位置：`app/service/` 目录下
- 命名空间：`app\service`

### 3.4 业务层间通信规范
```php
<?php
namespace app\service;

class UserService
{
    public function createUserWithRole($userData, $roleIds)
    {
        // 创建用户
        $user = $this->userModel->create($userData);
        
        // 通过app()调用其他服务（不直接操作角色模型）
        app('roleService')->assignRolesToUser($user->id, $roleIds);
        
        // 设置用户部门
        app('departmentService')->setUserDepartment($user->id, $userData['department_id']);
        
        return $user;
    }
    
    public function batchDelete($userIds, $operationId)
    {
        foreach ($userIds as $userId) {
            // 检查权限
            if (!app('permissionService')->canDeleteUser($userId)) {
                throw new \think\Exception("用户ID {$userId} 无删除权限");
            }
            
            // 清理相关数据
            app('menuService')->clearUserMenus($userId);
            app('roleService')->clearUserRoles($userId);
        }
        
        // 批量删除用户
        return $this->userModel->whereIn('id', $userIds)->delete();
    }
}
```

## 4. 依赖注入规范

### 4.1 Provider注册
所有业务层服务必须在 `app/provider.php` 中注册：

```php
<?php
use app\ExceptionHandle;
use app\Request;

// 容器Provider定义文件
// 这个是系统自带的服务。在这里添加服务
return [
    'think\Request'          => Request::class,
    'think\exception\Handle' => ExceptionHandle::class,
    
    // 业务层服务注册（使用服务名称绑定）
    'database'               => \app\service\DatabaseService::class,
    'productService'         => \app\service\ProductService::class,
    'staffService'           => \app\service\StaffService::class,
    'permissionService'      => \app\service\PermissionService::class,
    'merchantService'        => \app\service\MerchantService::class,
    'templateService'        => \app\service\TemplateService::class,
    'websiteTemplateService' => \app\service\WebsiteTemplateService::class,
    'emailService'           => \app\service\EmailService::class,
    'menuService'            => \app\service\MenuService::class,
    'userService'            => \app\service\UserService::class,
    'roleService'            => \app\service\RoleService::class,
];
```

### 4.2 服务调用方式
使用 `app()` 助手函数直接获取服务实例：

```php
// 在控制器中使用
class UserController extends BaseController
{
    public function delete()
    {
        $userIds = $this->request->param('ids');
        $operationId = $this->request->param('operation_id');
        // 直接通过app()获取服务实例
        $result = app('userService')->delete($userIds, $operationId);
        return json($result);
    }
    
    public function createWithRole()
    {
        $userData = $this->request->param();
        
        // 调用用户服务
        $result = app('userService')->createWithRole($userData);
        
        return json($result);
    }
}

// 在业务层中使用其他业务层服务
class UserService
{
    public function createWithRole($userData)
    {
        try {
            // 创建用户
            $user = $this->userModel->create($userData);
            
            // 通过app()调用其他服务（不需要构造函数注入）
            app('roleService')->assignRolesToUser($user->id, $userData['role_ids']);
            
            return [
                'msg' => '用户创建成功',
                'data' => $user,
                'code' => ClientEnum::CREATED->value
            ];
            
        } catch (\Exception $e) {
            return [
                'msg' => '用户创建失败：' . $e->getMessage(),
                'data' => null,
                'code' => ClientEnum::INTERNAL_ERROR->value
            ];
        }
    }
    
    public function deleteUser($userId)
    {
        // 检查权限
        $hasPermission = app('permissionService')->checkUserPermission($userId, 'delete');
        if (!$hasPermission) {
            return [
                'msg' => '无权限删除用户',
                'data' => null,
                'code' => ClientEnum::FORBIDDEN->value
            ];
        }
        
        // 删除相关数据
        app('menuService')->deleteUserMenus($userId);
        
        // 删除用户
        $result = $this->userModel->delete($userId);
        
        return [
            'msg' => $result ? '用户删除成功' : '用户删除失败',
            'data' => $result,
            'code' => $result ? ClientEnum::SUCCESS->value : ClientEnum::BAD_REQUEST->value
        ];
    }
}
```

## 5. 代码组织规范

### 5.1 禁止行为
- ❌ 在一个业务层中直接实例化其他模型进行操作
- ❌ 在业务层中混写其他模型的业务逻辑
- ❌ 跨业务层直接调用私有方法
- ❌ 在模型中写复杂的业务流程逻辑

### 5.2 推荐行为
- ✅ 通过依赖注入使用其他业务层服务
- ✅ 将简单重复的逻辑抽取为公共方法
- ✅ 复杂业务逻辑统一放在对应的业务层
- ✅ 保持业务层方法的单一职责

## 6. 返回格式规范

### 6.1 统一返回格式
所有业务层方法必须返回统一的数组格式，包含 `msg`、`data` 和 `code` 三个字段：

```php
use app\enum\ClientEnum;

// 成功返回格式
return [
    'msg' => '操作成功',
    'data' => $result,
    'code' => ClientEnum::SUCCESS->value  // 使用枚举，防止乱写状态码
];

// 失败返回格式  
return [
    'msg' => '操作失败的具体原因',
    'data' => null,
    'code' => ClientEnum::BAD_REQUEST->value
];
```

### 6.2 状态码枚举规范

为了防止开发者乱写状态码，必须使用 `ClientEnum` 枚举：

```php
<?php
namespace app\enum;

enum ClientEnum: int
{
    // 成功状态码
    case SUCCESS = 200;         // 操作成功
    case CREATED = 201;         // 创建成功
    
    // 客户端错误状态码
    case BAD_REQUEST = 400;     // 业务逻辑失败
    case UNAUTHORIZED = 401;    // 认证失败
    case FORBIDDEN = 403;       // 权限不足
    case NOT_FOUND = 404;       // 资源不存在
    case VALIDATION_ERROR = 422; // 数据验证失败
    
    // 服务器错误状态码
    case INTERNAL_ERROR = 500;  // 系统异常
    
    // 获取状态码描述、判断状态等方法...
}
```

**使用规范：**
- ✅ **必须使用枚举**：`ClientEnum::SUCCESS->value`
- ❌ **禁止直接写数字**：`'code' => 200`
- ✅ **IDE有提示**：枚举提供代码补全
- ✅ **统一管理**：所有状态码在一个文件中维护

### 6.3 控制器处理方式
控制器直接使用业务层返回的数组，HTTP状态码统一使用200（成功响应）或500（系统异常）：

```php
class UserController extends BaseController
{
    public function create()
    {
        $userData = $this->request->param();
        
        try {
            $result = app('userService')->createUser($userData);
            
            // 统一返回200状态码，业务成功失败通过result.code判断
            return json($result, 200);
            
        } catch (\think\Exception $e) {
            // 系统异常返回500
            return json([
                'msg' => $e->getMessage(),
                'data' => null,
                'code' => 500
            ], 500);
        }
    }
    
    public function update($id)
    {
        $userData = $this->request->param();
        $result = app('userService')->updateUser($id, $userData);
        
        // 统一返回200，不管业务成功失败
        return json($result, 200);
    }
    
    public function delete($id)
    {
        $result = app('userService')->deleteUser($id);
        
        // 统一返回200
        return json($result, 200);
    }
    
    public function show($id)
    {
        $result = app('userService')->getUserById($id);
        
        return json($result, 200);
    }
    
    // 直接使用json()函数返回
    public function list()
    {
        $params = $this->request->param();
        
        try {
            $result = app('userService')->getUserList($params);
            
            // 可选：添加时间戳
            if (config('app.add_timestamp', true)) {
                $result['timestamp'] = time();
            }
            
            // 直接返回，统一使用200状态码
            return json($result, 200);
            
        } catch (\think\Exception $e) {
            // 系统异常返回500
            return json([
                'msg' => $e->getMessage(),
                'data' => null,
                'code' => 500,
                'timestamp' => time()
            ], 500);
        }
         }
 }
 ```

### 6.4 控制器使用建议

**推荐的控制器写法：**

```php
class UserController
{
    public function index()
    {
        try {
            $result = app('userService')->getUserList($this->request->param());
            
            // 可选：添加通用字段
            $result['timestamp'] = time();
            $result['request_id'] = $this->request->header('X-Request-ID') ?: uniqid();
            
            return json($result, 200);
            
        } catch (\Exception $e) {
            return json([
                'msg' => $e->getMessage(),
                'data' => null,
                'code' => 500,
                'timestamp' => time()
            ], 500);
        }
    }
    
    public function store()
    {
        $result = app('userService')->createUser($this->request->param());
        
        // 简单场景直接返回
        return json($result, 200);
    }
}
```

**核心原则：**
- ✅ 直接使用 `json()` 函数，简洁明了
- ✅ HTTP状态码只用200（业务响应）和500（系统异常）
- ✅ 业务成功失败通过返回数据中的 `code` 字段判断
- ✅ 需要额外字段（如timestamp）时直接添加到结果数组中

### 6.5 HTTP状态码与业务状态码分离

**HTTP状态码（控制器层面）：**
- **200**：服务器成功响应请求（不管业务成功失败）
- **500**：服务器系统异常（catch到Exception时使用）

**业务状态码（业务层返回的code字段）：**

| code值 | 场景 | 说明 |
|--------|------|------|
| 200 | 查询、更新、删除成功 | 业务操作成功 |
| 201 | 创建成功 | 资源创建成功 |
| 400 | 业务逻辑失败 | 请求参数错误或业务规则不通过 |
| 401 | 认证失败 | 未登录或token无效 |
| 403 | 权限不足 | 已登录但无权限访问 |
| 404 | 资源不存在 | 查询的资源不存在 |
| 422 | 数据验证失败 | 请求数据格式正确但验证不通过 |
| 500 | 系统异常 | 服务器内部错误 |

### 6.6 业务层返回示例

```php
use app\enum\ClientEnum;

class UserService
{
    /**
     * 创建用户
     * @param array $userData 用户数据
     * @return array
     */
    public function createUser($userData)
    {
        // 数据验证
        $validate = new \app\validate\UserValidate();
        if (!$validate->check($userData)) {
            return [
                'msg' => $validate->getError(),
                'data' => null,
                'code' => ClientEnum::VALIDATION_ERROR->value
            ];
        }
        
        // 检查用户名唯一性
        if (!$this->userModel->checkUnique('username', $userData['username'])) {
            return [
                'msg' => '用户名已存在',
                'data' => null,
                'code' => ClientEnum::BAD_REQUEST->value
            ];
        }
        
        try {
            // 创建用户
            $user = $this->userModel->create($userData);
            
            return [
                'msg' => '用户创建成功',
                'data' => $user,
                'code' => ClientEnum::CREATED->value
            ];
            
        } catch (\Exception $e) {
            return [
                'msg' => '用户创建失败：' . $e->getMessage(),
                'data' => null,
                'code' => ClientEnum::INTERNAL_ERROR->value
            ];
        }
    }
    
    /**
     * 获取用户信息
     * @param int $userId 用户ID
     * @return array
     */
    public function getUserById($userId)
    {
        $user = $this->userModel->find($userId);
        
        if (!$user) {
            return [
                'msg' => '用户不存在',
                'data' => null,
                'code' => ClientEnum::NOT_FOUND->value
            ];
        }
        
        return [
            'msg' => '获取用户信息成功',
            'data' => $user,
            'code' => ClientEnum::SUCCESS->value
        ];
    }
    
    /**
     * 删除用户
     * @param int $userId 用户ID
     * @return array
     */
    public function deleteUser($userId)
    {
                 // 检查是否为超级管理员
        if ($this->userModel->isSuperAdmin($userId)) {
            return [
                'msg' => '超级管理员不能删除',
                'data' => null,
                'code' => ClientEnum::FORBIDDEN->value
            ];
        }
        
        try {
            // 清理相关数据
            app('roleService')->clearUserRoles($userId);
            app('menuService')->clearUserMenus($userId);
            
            // 删除用户
            $result = $this->userModel->delete($userId);
            
            return [
                'msg' => $result ? '用户删除成功' : '用户删除失败',
                'data' => $result,
                'code' => $result ? ClientEnum::SUCCESS->value : ClientEnum::BAD_REQUEST->value
            ];
            
        } catch (\Exception $e) {
            return [
                'msg' => '删除用户时发生错误：' . $e->getMessage(),
                'data' => null,
                'code' => ClientEnum::INTERNAL_ERROR->value
            ];
        }
    }
    
    /**
     * 批量删除用户
     * @param array $userIds 用户ID数组
     * @return array
     */
    public function batchDelete($userIds)
    {
        $successCount = 0;
        $failedUsers = [];
        
        foreach ($userIds as $userId) {
            $result = $this->deleteUser($userId);
            
            if ($result['data']) {
                $successCount++;
            } else {
                $failedUsers[] = [
                    'user_id' => $userId,
                    'reason' => $result['msg']
                ];
            }
        }
        
        return [
            'msg' => "成功删除 {$successCount} 个用户" . (count($failedUsers) > 0 ? "，失败 " . count($failedUsers) . " 个" : ""),
            'data' => [
                'success_count' => $successCount,
                'failed_users' => $failedUsers
            ],
            'code' => count($failedUsers) > 0 ? ClientEnum::BAD_REQUEST->value : ClientEnum::SUCCESS->value
        ];
    }
}
```

## 7. 异常处理规范

### 7.1 重要原则
⚠️ **业务层绝对不允许抛出异常！所有业务层方法必须返回统一的数组格式！**

### 7.2 业务异常处理
业务层不抛出异常，统一通过返回格式处理：

```php
// ❌ 错误做法：抛出异常
public function deleteUser($userId)
{
    if ($this->userModel->isSuperAdmin($userId)) {
        throw new \think\Exception('超级管理员不能删除');
    }
}

// ✅ 正确做法：返回错误信息
public function deleteUser($userId)
{
    if ($this->userModel->isSuperAdmin($userId)) {
        return [
            'msg' => '超级管理员不能删除',
            'data' => null,
            'code' => ClientEnum::FORBIDDEN->value
        ];
    }
}
```

### 7.3 系统异常处理
**业务层内部的系统异常也要转换为返回格式，不能向上抛出：**

```php
public function createUser($userData)
{
    try {
        // 业务逻辑
        $user = $this->userModel->create($userData);
        
        return [
            'msg' => '用户创建成功',
            'data' => $user,
            'code' => ClientEnum::CREATED->value
        ];
        
    } catch (\Exception $e) {
        // ✅ 系统异常也要转换为返回格式，不能抛出
        return [
            'msg' => '系统错误：' . $e->getMessage(),
            'data' => null,
            'code' => ClientEnum::INTERNAL_ERROR->value
        ];
    }
}
```

### 7.4 控制器异常处理
只有控制器可以抛出异常（用于框架层面的错误处理）：

```php
public function create()
{
    try {
        $result = app('userService')->createUser($this->request->param());
        
        // 业务层已经处理了所有异常，这里只需要返回结果
        return json($result, 200);
        
    } catch (\Exception $e) {
        // 这里捕获的是框架级异常，如服务不存在等
        return json([
            'msg' => '系统异常：' . $e->getMessage(),
            'data' => null,
            'code' => ClientEnum::INTERNAL_ERROR->value
        ], 500);
    }
}

## 8. 性能优化规范

### 8.1 查询优化
- 避免N+1查询问题
- 合理使用预加载（with）
- 复杂查询考虑使用原生SQL

### 8.2 缓存使用
```php
// 在业务层中使用缓存
public function getUserMenus($userId)
{
    $cacheKey = 'user_menus_' . $userId;
    
    return cache($cacheKey, function() use ($userId) {
        // 复杂的菜单查询逻辑
        return $this->buildUserMenuTree($userId);
    }, 3600);
}
```

## 9. 测试规范

### 9.1 单元测试
- 每个业务层服务都应该有对应的单元测试
- 使用Mock对象模拟依赖的其他服务
- 测试覆盖主要业务场景和异常情况

### 9.2 集成测试
- 测试业务层之间的交互
- 验证完整的业务流程

## 10. 文档规范

### 10.1 方法注释
```php
/**
 * 创建用户并分配角色
 * @param array $userData 用户数据
 * @param array $roleIds 角色ID数组
 * @return array 返回格式：['msg' => string, 'data' => object|null, 'code' => int]
 */
public function createUserWithRole($userData, $roleIds)
{
    // 实现逻辑
}
```

### 10.2 业务流程文档
- 复杂业务流程需要有对应的流程图
- 关键业务逻辑需要有详细的文档说明

## 11. 版本控制规范

### 11.1 提交规范
- 业务层修改需要明确说明影响范围
- 接口变更需要更新版本号
- 重要业务逻辑修改需要详细的commit message

### 11.2 向后兼容
- 业务层接口修改需要考虑向后兼容性
- 废弃方法需要标记@deprecated并给出替代方案
